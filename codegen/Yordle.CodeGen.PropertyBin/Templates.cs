using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace Yordle.CodeGen.PropertyBin;

public static class Templates {
    // language=c++
    public const string BIN_DISPATCH_MAIN = @"/// <auto-generated>

#include <yordle/data/meta/bin_dispatch.hpp>
%{BIN_REF}

using namespace std;
using namespace yordle::data::meta;

map<uint32_t, function<prop_ret(prop_arg)>> yordle::data::meta::bin_dispatch::table;

void yordle::data::meta::bin_dispatch::load_table() {
    if (!table.empty()) {
        return;
    }

%{TABLE_ENTRIES}
}
";

    // language=c++
    public const string BIN_DISPATCH_ENTRY = @"    table[%{HASH}] = [](prop_arg prop) { return make_shared<yordle::data::meta::%{NAME}>(prop); };";

    // language=c++
    public const string BIN_CLASS_DEF_MAIN = @"/// <auto-generated>
#pragma once

%{STDLIB}

%{CLASS_IMPL_REF}
#include <yordle/data/meta/bin_ref.hpp>
#include <yordle/data/prop/structure_prop.hpp>
#include <yordle/yordle_export.h>

namespace yordle::data::meta {

%{CLASS_REF}
    struct YORDLE_EXPORT %{NAME} : %{BASE_CLASS} {
        explicit %{NAME}(const std::shared_ptr<yordle::data::prop::structure_prop> &prop);

        bool is_type(uint32_t type) override {
            return type == %{HASH}%{TYPE_CHECK};
        }

%{PROPERTIES}
    }
}
";

    // language=c++
    public const string BIN_CLASS_DEF_BASE_REF = @"#include <yordle/data/meta/bin_defs/%{NAME}.hpp>";

    // language=c++
    public const string BIN_CLASS_DEF_PROP_REF = @"#include <yordle/data/prop/%{NAME}_prop.hpp>";

    // language=c++
    public const string BIN_CLASS_DEF_STDLIB_REF = @"#include <%{NAME}>";

    // language=c++
    public const string BIN_CLASS_DEF_CLASS_REF = @"    struct %{REF};";

    // language=c++
    public const string BIN_CLASS_DEF_CLASS_IS_TYPE = @"|| %{BASE_CLASS}.is_type(type)";

    // language=c++
    public const string BIN_CLASS_DEF_CLASS_PROPERTY = @"        %{TYPE} %{NAME} = %{DEFAULT};";

    // language=c++
    public const string BIN_CLASS_IMPL = @"/// <auto-generated>
#include <yordle/data/meta/bin_defs/%{NAME}.hpp>

%{CLASS_REF}

yordle::data::meta::%{NAME}::%{NAME}(const std::shared_ptr<yordle::data::prop::structure_prop> &prop) : %{BASE_CLASS} {
    if(prop == nullptr) {
        return;
    }

%{PROPERTIES}
}
";

    // language=c++
    public const string BIN_CLASS_IMPL_BASE = @"yordle::data::meta::%{NAME}(prop)";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE = @"
auto ptr_%{NAME} = prop->cast_prop<%{TYPE}>(%{HASH});
if(ptr_%{NAME} != nullptr) {
    %{NAME} = %{SUB_LOGIC};
}
";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE_SUB_LOGIC = @"ptr_%{NAME}->value";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE_SUB_LOGIC_BIT = @"(ptr_%{NAME}->value & %{BIT}) == %{BIT}";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE_SUB_LOGIC_POINTER = @"yordle::data::meta::deserialize<yordle::data::meta::%{CLASS}>(ptr_%{NAME}, %{HASH})";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE_SUB_LOGIC_EMBED = @"yordle::data::meta::bin_ref<yordle::data::meta::%{CLASS}>(%{HASH}, ptr_%{NAME}.value)";

    // language=c++
    public const string BIN_CLASS_IMPL_VALUE_SUB_LOGIC_OPTIONAL = @"
auto ptr_%{NAME}_opt = yordle::data::prop::empty_prop::cast_prop<yordle::data::prop::%{VALUE_TYPE}>(ptr_${NAME}->value);
if (ptr_%{NAME}_opt != nullptr) {
    %{NAME} = %{SUB_LOGIC};
}
";

    // language=c++
    public const string BIN_CLASS_IMPL_SET = @"
auto ptr_%{NAME} = prop->cast_prop<%{TYPE}>(%{HASH});
if(ptr_%{NAME} != nullptr) {
    for(const auto &set_%{NAME}_entry : ptr_%{NAME}->value) {
        auto ptr_%{NAME}_entry = yordle::data::prop::empty_prop::cast_prop<%{VALUE_TYPE}>(set_%{NAME}_entry);
        if(ptr_%{NAME}_entry != nullptr) {
            %{NAME}.emplace_back(%{SUB_LOGIC});
        }
    }
}
";

    // language=c++
    public const string BIN_CLASS_IMPL_FIXED_SET = @"
auto ptr_%{NAME} = prop->cast_prop<%{TYPE}>(%{HASH});
if(ptr_%{NAME} != nullptr) {
    auto index_%{NAME} = 0;
    for(const auto &set_%{NAME}_entry : ptr_%{NAME}->value) {
        auto ptr_%{NAME}_entry = yordle::data::prop::empty_prop::cast_prop<%{VALUE_TYPE}>(set_%{NAME}_entry);
        if(ptr_%{NAME}_entry != nullptr) {
            %{NAME}[index_%{NAME}] = %{SUB_LOGIC};
        }
        index_%{NAME}++;
    }
}
";

    // language=c++
    public const string BIN_CLASS_IMPL_MAP = @"
auto ptr_%{NAME} = prop->cast_prop<%{TYPE}>(%{HASH});
if(ptr_%{NAME} != nullptr) {
    for(const auto &set_%{NAME}_pair : ptr_%{NAME}->value) {
        auto ptr_%{NAME}_key = yordle::data::prop::empty_prop::cast_prop<%{KEY_TYPE}>(set_%{NAME}_pair.first);
        auto ptr_%{NAME}_value = yordle::data::prop::empty_prop::cast_prop<%{VALUE_TYPE}>(set_%{NAME}_pair.second);
        if(ptr_%{NAME}_key != nullptr && ptr_%{NAME}_value != nullptr) {
            %{NAME}.emplace(%{SUB_LOGIC_KEY}, %{SUB_LOGIC_VALUE});
        }
    }
}
";

    public static string CompileTemplate(string template, Dictionary<string, object> values) {
        foreach (var (key, rawValue) in values) {
            var value = rawValue;
            if (value is IEnumerable<string> enumerable) {
                value = string.Join('\n', enumerable);
            }

            template = template.Replace($"%{{{key.ToUpper()}}}", value.ToString());
        }

        template = template.Replace("\r\n", "\n");

        while (template.Contains("\n\n\n")) {
            template = template.Replace("\n\n\n", "\n");
        }

        if (template.Contains("%{")) {
            Debug.WriteLine(template);
            throw new InvalidDataException("template needs more variables, see debug stack");
        }

        return template.TrimEnd();
    }
}
