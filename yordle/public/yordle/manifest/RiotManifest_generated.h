// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RIOTMANIFEST_YORDLE_MANIFEST_GENERATED_H_
#define FLATBUFFERS_GENERATED_RIOTMANIFEST_YORDLE_MANIFEST_GENERATED_H_

#include "flatbuffers/flatbuffers.h"

namespace yordle {
namespace manifest {
namespace generated {

struct RiotManifest;
struct RiotManifestBuilder;

struct RiotManifestBundle;
struct RiotManifestBundleBuilder;

struct RiotManifestBlock;
struct RiotManifestBlockBuilder;

struct RiotManifestLanguage;
struct RiotManifestLanguageBuilder;

struct RiotManifestFile;
struct RiotManifestFileBuilder;

struct RiotManifestDirectory;
struct RiotManifestDirectoryBuilder;

struct RiotManifestKey;
struct RiotManifestKeyBuilder;

struct RiotManifestParam;
struct RiotManifestParamBuilder;

enum class RiotManifestParamType : uint8_t {
  NONE = 0,
  SHA512 = 1,
  SHA256 = 2,
  HKDF = 3,
  MIN = NONE,
  MAX = HKDF
};

inline const RiotManifestParamType (&EnumValuesRiotManifestParamType())[4] {
  static const RiotManifestParamType values[] = {
    RiotManifestParamType::NONE,
    RiotManifestParamType::SHA512,
    RiotManifestParamType::SHA256,
    RiotManifestParamType::HKDF
  };
  return values;
}

inline const char * const *EnumNamesRiotManifestParamType() {
  static const char * const names[5] = {
    "NONE",
    "SHA512",
    "SHA256",
    "HKDF",
    nullptr
  };
  return names;
}

inline const char *EnumNameRiotManifestParamType(RiotManifestParamType e) {
  if (flatbuffers::IsOutRange(e, RiotManifestParamType::NONE, RiotManifestParamType::HKDF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRiotManifestParamType()[index];
}

struct RiotManifest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUNDLES = 4,
    VT_LANGUAGES = 6,
    VT_FILES = 8,
    VT_DIRECTORIES = 10,
    VT_KEYS = 12,
    VT_PARAMS = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>> *bundles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>> *>(VT_BUNDLES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>> *languages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>> *>(VT_LANGUAGES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>> *directories() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>> *>(VT_DIRECTORIES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>> *>(VT_KEYS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>> *params() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>> *>(VT_PARAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUNDLES) &&
           verifier.VerifyVector(bundles()) &&
           verifier.VerifyVectorOfTables(bundles()) &&
           VerifyOffset(verifier, VT_LANGUAGES) &&
           verifier.VerifyVector(languages()) &&
           verifier.VerifyVectorOfTables(languages()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyOffset(verifier, VT_DIRECTORIES) &&
           verifier.VerifyVector(directories()) &&
           verifier.VerifyVectorOfTables(directories()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfTables(keys()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.VerifyVectorOfTables(params()) &&
           verifier.EndTable();
  }
};

struct RiotManifestBuilder {
  typedef RiotManifest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bundles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>>> bundles) {
    fbb_.AddOffset(RiotManifest::VT_BUNDLES, bundles);
  }
  void add_languages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>>> languages) {
    fbb_.AddOffset(RiotManifest::VT_LANGUAGES, languages);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>>> files) {
    fbb_.AddOffset(RiotManifest::VT_FILES, files);
  }
  void add_directories(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>>> directories) {
    fbb_.AddOffset(RiotManifest::VT_DIRECTORIES, directories);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>>> keys) {
    fbb_.AddOffset(RiotManifest::VT_KEYS, keys);
  }
  void add_params(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>>> params) {
    fbb_.AddOffset(RiotManifest::VT_PARAMS, params);
  }
  explicit RiotManifestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifest> CreateRiotManifest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>>> bundles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>>> languages = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>>> directories = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>>> params = 0) {
  RiotManifestBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_keys(keys);
  builder_.add_directories(directories);
  builder_.add_files(files);
  builder_.add_languages(languages);
  builder_.add_bundles(bundles);
  return builder_.Finish();
}

struct RiotManifest::Traits {
  using type = RiotManifest;
  static auto constexpr Create = CreateRiotManifest;
};

inline flatbuffers::Offset<RiotManifest> CreateRiotManifestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>> *bundles = nullptr,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>> *languages = nullptr,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>> *files = nullptr,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>> *directories = nullptr,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>> *keys = nullptr,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>> *params = nullptr) {
  auto bundles__ = bundles ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBundle>>(*bundles) : 0;
  auto languages__ = languages ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestLanguage>>(*languages) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestFile>>(*files) : 0;
  auto directories__ = directories ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestDirectory>>(*directories) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestKey>>(*keys) : 0;
  auto params__ = params ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestParam>>(*params) : 0;
  return yordle::manifest::generated::CreateRiotManifest(
      _fbb,
      bundles__,
      languages__,
      files__,
      directories__,
      keys__,
      params__);
}

struct RiotManifestBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestBundleBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_ID = 4,
    VT_BLOCKS = 6
  };
  uint64_t block_id() const {
    return GetField<uint64_t>(VT_BLOCK_ID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>> *blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>> *>(VT_BLOCKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BLOCK_ID, 8) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           verifier.EndTable();
  }
};

struct RiotManifestBundleBuilder {
  typedef RiotManifestBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_id(uint64_t block_id) {
    fbb_.AddElement<uint64_t>(RiotManifestBundle::VT_BLOCK_ID, block_id, 0);
  }
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>>> blocks) {
    fbb_.AddOffset(RiotManifestBundle::VT_BLOCKS, blocks);
  }
  explicit RiotManifestBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestBundle> CreateRiotManifestBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t block_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>>> blocks = 0) {
  RiotManifestBundleBuilder builder_(_fbb);
  builder_.add_block_id(block_id);
  builder_.add_blocks(blocks);
  return builder_.Finish();
}

struct RiotManifestBundle::Traits {
  using type = RiotManifestBundle;
  static auto constexpr Create = CreateRiotManifestBundle;
};

inline flatbuffers::Offset<RiotManifestBundle> CreateRiotManifestBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t block_id = 0,
    const std::vector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>> *blocks = nullptr) {
  auto blocks__ = blocks ? _fbb.CreateVector<flatbuffers::Offset<yordle::manifest::generated::RiotManifestBlock>>(*blocks) : 0;
  return yordle::manifest::generated::CreateRiotManifestBundle(
      _fbb,
      block_id,
      blocks__);
}

struct RiotManifestBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestBlockBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_ID = 4,
    VT_COMPRESSED_SIZE = 6,
    VT_SIZE = 8
  };
  uint64_t block_id() const {
    return GetField<uint64_t>(VT_BLOCK_ID, 0);
  }
  uint32_t compressed_size() const {
    return GetField<uint32_t>(VT_COMPRESSED_SIZE, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_BLOCK_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_COMPRESSED_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct RiotManifestBlockBuilder {
  typedef RiotManifestBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_id(uint64_t block_id) {
    fbb_.AddElement<uint64_t>(RiotManifestBlock::VT_BLOCK_ID, block_id, 0);
  }
  void add_compressed_size(uint32_t compressed_size) {
    fbb_.AddElement<uint32_t>(RiotManifestBlock::VT_COMPRESSED_SIZE, compressed_size, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(RiotManifestBlock::VT_SIZE, size, 0);
  }
  explicit RiotManifestBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestBlock> CreateRiotManifestBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t block_id = 0,
    uint32_t compressed_size = 0,
    uint32_t size = 0) {
  RiotManifestBlockBuilder builder_(_fbb);
  builder_.add_block_id(block_id);
  builder_.add_size(size);
  builder_.add_compressed_size(compressed_size);
  return builder_.Finish();
}

struct RiotManifestBlock::Traits {
  using type = RiotManifestBlock;
  static auto constexpr Create = CreateRiotManifestBlock;
};

struct RiotManifestLanguage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestLanguageBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LANGUAGE_ID = 4,
    VT_NAME = 6
  };
  int8_t language_id() const {
    return GetField<int8_t>(VT_LANGUAGE_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LANGUAGE_ID, 1) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RiotManifestLanguageBuilder {
  typedef RiotManifestLanguage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_language_id(int8_t language_id) {
    fbb_.AddElement<int8_t>(RiotManifestLanguage::VT_LANGUAGE_ID, language_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RiotManifestLanguage::VT_NAME, name);
  }
  explicit RiotManifestLanguageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestLanguage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestLanguage>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestLanguage> CreateRiotManifestLanguage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t language_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RiotManifestLanguageBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_language_id(language_id);
  return builder_.Finish();
}

struct RiotManifestLanguage::Traits {
  using type = RiotManifestLanguage;
  static auto constexpr Create = CreateRiotManifestLanguage;
};

inline flatbuffers::Offset<RiotManifestLanguage> CreateRiotManifestLanguageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t language_id = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return yordle::manifest::generated::CreateRiotManifestLanguage(
      _fbb,
      language_id,
      name__);
}

struct RiotManifestFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestFileBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILE_ID = 4,
    VT_DIRECTORY_ID = 6,
    VT_SIZE = 8,
    VT_NAME = 10,
    VT_LANGUAGE_FLAGS = 12,
    VT_UNKNOWN3 = 14,
    VT_UNKNOWN4 = 16,
    VT_BLOCK_IDS = 18,
    VT_IS_BUNDLE_HIERARCHY = 20,
    VT_LINK = 22,
    VT_UNKNOWN8 = 24,
    VT_INDEX = 26,
    VT_PERMISSIONS = 28
  };
  uint64_t file_id() const {
    return GetField<uint64_t>(VT_FILE_ID, 0);
  }
  uint64_t directory_id() const {
    return GetField<uint64_t>(VT_DIRECTORY_ID, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t language_flags() const {
    return GetField<uint32_t>(VT_LANGUAGE_FLAGS, 0);
  }
  uint32_t unknown3() const {
    return GetField<uint32_t>(VT_UNKNOWN3, 0);
  }
  uint32_t unknown4() const {
    return GetField<uint32_t>(VT_UNKNOWN4, 0);
  }
  const flatbuffers::Vector<uint64_t> *block_ids() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_BLOCK_IDS);
  }
  bool is_bundle_hierarchy() const {
    return GetField<uint8_t>(VT_IS_BUNDLE_HIERARCHY, 0) != 0;
  }
  const flatbuffers::String *link() const {
    return GetPointer<const flatbuffers::String *>(VT_LINK);
  }
  uint8_t unknown8() const {
    return GetField<uint8_t>(VT_UNKNOWN8, 0);
  }
  uint8_t index() const {
    return GetField<uint8_t>(VT_INDEX, 0);
  }
  uint8_t permissions() const {
    return GetField<uint8_t>(VT_PERMISSIONS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FILE_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_DIRECTORY_ID, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_LANGUAGE_FLAGS, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNKNOWN3, 4) &&
           VerifyField<uint32_t>(verifier, VT_UNKNOWN4, 4) &&
           VerifyOffset(verifier, VT_BLOCK_IDS) &&
           verifier.VerifyVector(block_ids()) &&
           VerifyField<uint8_t>(verifier, VT_IS_BUNDLE_HIERARCHY, 1) &&
           VerifyOffset(verifier, VT_LINK) &&
           verifier.VerifyString(link()) &&
           VerifyField<uint8_t>(verifier, VT_UNKNOWN8, 1) &&
           VerifyField<uint8_t>(verifier, VT_INDEX, 1) &&
           VerifyField<uint8_t>(verifier, VT_PERMISSIONS, 1) &&
           verifier.EndTable();
  }
};

struct RiotManifestFileBuilder {
  typedef RiotManifestFile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file_id(uint64_t file_id) {
    fbb_.AddElement<uint64_t>(RiotManifestFile::VT_FILE_ID, file_id, 0);
  }
  void add_directory_id(uint64_t directory_id) {
    fbb_.AddElement<uint64_t>(RiotManifestFile::VT_DIRECTORY_ID, directory_id, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(RiotManifestFile::VT_SIZE, size, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RiotManifestFile::VT_NAME, name);
  }
  void add_language_flags(uint32_t language_flags) {
    fbb_.AddElement<uint32_t>(RiotManifestFile::VT_LANGUAGE_FLAGS, language_flags, 0);
  }
  void add_unknown3(uint32_t unknown3) {
    fbb_.AddElement<uint32_t>(RiotManifestFile::VT_UNKNOWN3, unknown3, 0);
  }
  void add_unknown4(uint32_t unknown4) {
    fbb_.AddElement<uint32_t>(RiotManifestFile::VT_UNKNOWN4, unknown4, 0);
  }
  void add_block_ids(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> block_ids) {
    fbb_.AddOffset(RiotManifestFile::VT_BLOCK_IDS, block_ids);
  }
  void add_is_bundle_hierarchy(bool is_bundle_hierarchy) {
    fbb_.AddElement<uint8_t>(RiotManifestFile::VT_IS_BUNDLE_HIERARCHY, static_cast<uint8_t>(is_bundle_hierarchy), 0);
  }
  void add_link(flatbuffers::Offset<flatbuffers::String> link) {
    fbb_.AddOffset(RiotManifestFile::VT_LINK, link);
  }
  void add_unknown8(uint8_t unknown8) {
    fbb_.AddElement<uint8_t>(RiotManifestFile::VT_UNKNOWN8, unknown8, 0);
  }
  void add_index(uint8_t index) {
    fbb_.AddElement<uint8_t>(RiotManifestFile::VT_INDEX, index, 0);
  }
  void add_permissions(uint8_t permissions) {
    fbb_.AddElement<uint8_t>(RiotManifestFile::VT_PERMISSIONS, permissions, 0);
  }
  explicit RiotManifestFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestFile> CreateRiotManifestFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_id = 0,
    uint64_t directory_id = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t language_flags = 0,
    uint32_t unknown3 = 0,
    uint32_t unknown4 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> block_ids = 0,
    bool is_bundle_hierarchy = false,
    flatbuffers::Offset<flatbuffers::String> link = 0,
    uint8_t unknown8 = 0,
    uint8_t index = 0,
    uint8_t permissions = 0) {
  RiotManifestFileBuilder builder_(_fbb);
  builder_.add_directory_id(directory_id);
  builder_.add_file_id(file_id);
  builder_.add_link(link);
  builder_.add_block_ids(block_ids);
  builder_.add_unknown4(unknown4);
  builder_.add_unknown3(unknown3);
  builder_.add_language_flags(language_flags);
  builder_.add_name(name);
  builder_.add_size(size);
  builder_.add_permissions(permissions);
  builder_.add_index(index);
  builder_.add_unknown8(unknown8);
  builder_.add_is_bundle_hierarchy(is_bundle_hierarchy);
  return builder_.Finish();
}

struct RiotManifestFile::Traits {
  using type = RiotManifestFile;
  static auto constexpr Create = CreateRiotManifestFile;
};

inline flatbuffers::Offset<RiotManifestFile> CreateRiotManifestFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t file_id = 0,
    uint64_t directory_id = 0,
    uint32_t size = 0,
    const char *name = nullptr,
    uint32_t language_flags = 0,
    uint32_t unknown3 = 0,
    uint32_t unknown4 = 0,
    const std::vector<uint64_t> *block_ids = nullptr,
    bool is_bundle_hierarchy = false,
    const char *link = nullptr,
    uint8_t unknown8 = 0,
    uint8_t index = 0,
    uint8_t permissions = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto block_ids__ = block_ids ? _fbb.CreateVector<uint64_t>(*block_ids) : 0;
  auto link__ = link ? _fbb.CreateString(link) : 0;
  return yordle::manifest::generated::CreateRiotManifestFile(
      _fbb,
      file_id,
      directory_id,
      size,
      name__,
      language_flags,
      unknown3,
      unknown4,
      block_ids__,
      is_bundle_hierarchy,
      link__,
      unknown8,
      index,
      permissions);
}

struct RiotManifestDirectory FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestDirectoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PARENT_ID = 6,
    VT_NAME = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint64_t parent_id() const {
    return GetField<uint64_t>(VT_PARENT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_PARENT_ID, 8) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RiotManifestDirectoryBuilder {
  typedef RiotManifestDirectory Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(RiotManifestDirectory::VT_ID, id, 0);
  }
  void add_parent_id(uint64_t parent_id) {
    fbb_.AddElement<uint64_t>(RiotManifestDirectory::VT_PARENT_ID, parent_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RiotManifestDirectory::VT_NAME, name);
  }
  explicit RiotManifestDirectoryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestDirectory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestDirectory>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestDirectory> CreateRiotManifestDirectory(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t parent_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  RiotManifestDirectoryBuilder builder_(_fbb);
  builder_.add_parent_id(parent_id);
  builder_.add_id(id);
  builder_.add_name(name);
  return builder_.Finish();
}

struct RiotManifestDirectory::Traits {
  using type = RiotManifestDirectory;
  static auto constexpr Create = CreateRiotManifestDirectory;
};

inline flatbuffers::Offset<RiotManifestDirectory> CreateRiotManifestDirectoryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t parent_id = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return yordle::manifest::generated::CreateRiotManifestDirectory(
      _fbb,
      id,
      parent_id,
      name__);
}

struct RiotManifestKey FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestKeyBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNKNOWN1 = 4
  };
  uint8_t unknown1() const {
    return GetField<uint8_t>(VT_UNKNOWN1, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_UNKNOWN1, 1) &&
           verifier.EndTable();
  }
};

struct RiotManifestKeyBuilder {
  typedef RiotManifestKey Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unknown1(uint8_t unknown1) {
    fbb_.AddElement<uint8_t>(RiotManifestKey::VT_UNKNOWN1, unknown1, 0);
  }
  explicit RiotManifestKeyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestKey> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestKey>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestKey> CreateRiotManifestKey(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t unknown1 = 0) {
  RiotManifestKeyBuilder builder_(_fbb);
  builder_.add_unknown1(unknown1);
  return builder_.Finish();
}

struct RiotManifestKey::Traits {
  using type = RiotManifestKey;
  static auto constexpr Create = CreateRiotManifestKey;
};

struct RiotManifestParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RiotManifestParamBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_HASH_TYPE = 6,
    VT_UNKNOWN3 = 8,
    VT_MIN_SIZE = 10,
    VT_MAX_SIZE = 12
  };
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  yordle::manifest::generated::RiotManifestParamType hash_type() const {
    return static_cast<yordle::manifest::generated::RiotManifestParamType>(GetField<uint8_t>(VT_HASH_TYPE, 0));
  }
  uint8_t unknown3() const {
    return GetField<uint8_t>(VT_UNKNOWN3, 0);
  }
  uint32_t min_size() const {
    return GetField<uint32_t>(VT_MIN_SIZE, 0);
  }
  uint32_t max_size() const {
    return GetField<uint32_t>(VT_MAX_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyField<uint8_t>(verifier, VT_HASH_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_UNKNOWN3, 1) &&
           VerifyField<uint32_t>(verifier, VT_MIN_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct RiotManifestParamBuilder {
  typedef RiotManifestParam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(RiotManifestParam::VT_ID, id, 0);
  }
  void add_hash_type(yordle::manifest::generated::RiotManifestParamType hash_type) {
    fbb_.AddElement<uint8_t>(RiotManifestParam::VT_HASH_TYPE, static_cast<uint8_t>(hash_type), 0);
  }
  void add_unknown3(uint8_t unknown3) {
    fbb_.AddElement<uint8_t>(RiotManifestParam::VT_UNKNOWN3, unknown3, 0);
  }
  void add_min_size(uint32_t min_size) {
    fbb_.AddElement<uint32_t>(RiotManifestParam::VT_MIN_SIZE, min_size, 0);
  }
  void add_max_size(uint32_t max_size) {
    fbb_.AddElement<uint32_t>(RiotManifestParam::VT_MAX_SIZE, max_size, 0);
  }
  explicit RiotManifestParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RiotManifestParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RiotManifestParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<RiotManifestParam> CreateRiotManifestParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t id = 0,
    yordle::manifest::generated::RiotManifestParamType hash_type = yordle::manifest::generated::RiotManifestParamType::NONE,
    uint8_t unknown3 = 0,
    uint32_t min_size = 0,
    uint32_t max_size = 0) {
  RiotManifestParamBuilder builder_(_fbb);
  builder_.add_max_size(max_size);
  builder_.add_min_size(min_size);
  builder_.add_id(id);
  builder_.add_unknown3(unknown3);
  builder_.add_hash_type(hash_type);
  return builder_.Finish();
}

struct RiotManifestParam::Traits {
  using type = RiotManifestParam;
  static auto constexpr Create = CreateRiotManifestParam;
};

inline const yordle::manifest::generated::RiotManifest *GetRiotManifest(const void *buf) {
  return flatbuffers::GetRoot<yordle::manifest::generated::RiotManifest>(buf);
}

inline const yordle::manifest::generated::RiotManifest *GetSizePrefixedRiotManifest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<yordle::manifest::generated::RiotManifest>(buf);
}

inline bool VerifyRiotManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<yordle::manifest::generated::RiotManifest>(nullptr);
}

inline bool VerifySizePrefixedRiotManifestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<yordle::manifest::generated::RiotManifest>(nullptr);
}

inline void FinishRiotManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<yordle::manifest::generated::RiotManifest> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRiotManifestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<yordle::manifest::generated::RiotManifest> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace generated
}  // namespace manifest
}  // namespace yordle

#endif  // FLATBUFFERS_GENERATED_RIOTMANIFEST_YORDLE_MANIFEST_GENERATED_H_
